TOC: ((Tutorial - Of Effects and Shaders|Of Effects and Shaders))
Back: ((Tutorial Effects - Function Printing|Function Printing))
Next: ((Tutorial Effects - Normals|Normals))
---
Of course you can also define your own vertex data in a patch. Create a new patch with Mesh join/split and VertexBuffer join/split like this:

{img src = "VertexData_2010.11.29-21.16.52.png" title = ""}

You can clone the basic vertex shader from ((tutorial-effects-vertexshader-preparations|here)).

!! VertexBuffer (Join)

So lets use the VertexBuffer join node to put in our own z values for the grid, generated by a ((node:Perlin (2d))):

{img src = "VertexData_2010.11.29-21.36.47.png" title = ""}  

You can play with the inputs of the LinearSpreads to alter the landscape of the grid..

If you open an Inspektor and select the ((node:VertexBuffer (EX9.Geometry Join))) you can see all 'channels' which can pass per vertex data from the patch to the vertex shader:

{img src = "VertexData-VertexBuffer (EX9.Geometry Split)_2010.11.29-22.04.15.png" title = ""}

To access the additional data in the vertex shader you need to add the datafield and type to the input parameters of the vertex shader. For example normals and a second texture coordinate would look like:

^code(lang=hlsl):
vs2ps VS(
    float4 PosO  : POSITION,
    float3 NormO : NORMAL,
    float4 TexCd : TEXCOORD0,
    float4 TexCd2 : TEXCOORD1)
{
    ...
}
^

!! Texture Data in a Vertex Shader

Most of the new graphics cards can also access textures in the vertex shader. This is done with the function tex2Dlod:

^note:
In order to use the tex2Dlod function you need to use shader-profile vs_3_0 for the vertex shader to compile.
^

^code(lang=hlsl):
//texture
texture Tex <string uiname="Texture";>;
sampler Samp = sampler_state    //sampler for doing the texture-lookup
{
    Texture   = (Tex);          //apply a texture to the sampler
    MipFilter = LINEAR;         //set the sampler states
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

//texture transformation marked with semantic TEXTUREMATRIX 
//to achieve symmetric transformations
float4x4 tTex: TEXTUREMATRIX <string uiname="Texture Transform";>;

//the data structure: "vertexshader to pixelshader"
//used as output data of the VS function
//and as input data of the PS function
struct vs2ps
{
    float4 Pos  : POSITION;
    float2 TexCd : TEXCOORD0;
};

float Amount = 0.1;

vs2ps VS(
    float4 PosO  : POSITION,
    float4 TexCd : TEXCOORD0)
{
    //declare output struct
    vs2ps Out;
    
    //get the color in the texture
    float4 texColor = tex2Dlod(Samp, TexCd);
    
    //offset the z coordinate
    PosO.z += texColor.r * Amount;

    //transform position
    Out.Pos = mul(PosO, tWVP);
    
    //transform texturecoordinates
    Out.TexCd = mul(TexCd, tTex);

    return Out;
}
^

The patch is rather simple here:

{img src = "VertexData_2010.11.30-19.58.47.png" title = ""}

!!Arrays
It is also possible to pass arrays directly from the patch into the shader. To access the array values you can use the texture coordinate, or some other changing value:

^code(lang=hlsl):
float Amount = 0.1;

#define ArrSize 20
float2 Noise[ArrSize];

vs2ps VS(
    float4 PosO  : POSITION,
    float4 TexCd : TEXCOORD0)
{
    //declare output struct
    vs2ps Out;
    
    //get the color in the texture
    float4 texColor = tex2Dlod(Samp, TexCd);
    
    //offset the z coordinate
    PosO.z += texColor.r * Amount;
    
    PosO.xy += Noise[TexCd.x * (ArrSize-1)];

    //transform position
    Out.Pos = mul(PosO, tWVP);
    
    //transform texturecoordinates
    Out.TexCd = mul(TexCd, tTex);

    return Out;
}
^

We can use the patch from before:

{img src = "VertexData_2010.11.30-20.15.39.png" title = ""} 
---
Next: ((Tutorial Effects - Normals|Normals))
Back: ((Tutorial Effects - Function Printing|Function Printing))
TOC: ((Tutorial - Of Effects and Shaders|Of Effects and Shaders))


